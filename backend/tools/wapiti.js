const command = require('../Utils/command');
const fs = require('fs');
const config = require('../config/config');


const defaultScan = (url, proxy) => {
    return new Promise((resolve, reject) => {
        let commandToExec = "";
        if (proxy != "") {
            commandToExec = config.WAPITI + ' -u ' + checkURL(url) + ' -p ' + checkProxy(proxy) + ' -f json -o outputs/wapitiOutput';
        } else {
            commandToExec = config.WAPITI + ' -u ' + checkURL(url) + ' -f json -o outputs/wapitiOutput';
        }
        command.execCommand(commandToExec, 'wapiti')
            .then((commandOutput) => {
                resolve(commandOutput);
            })
            .catch((err) => {
                reject(err);
            });
    });
};

const sqliScan = (url, proxy) => {
    return new Promise((resolve, reject) => {
        let commandToExec = "";
        if (proxy != "") {
            commandToExec = config.WAPITI + ' -u ' + checkURL(url) + ' -m ' + config.wapiti_sql + ' -p ' + checkProxy(proxy) + ' -f json -o outputs/wapitiOutput_sqli';
        } else {
            commandToExec = config.WAPITI + ' -u ' + checkURL(url) + ' -m ' + config.wapiti_sql + ' -f json -o outputs/wapitiOutput_sqli';
        }
        command.execCommand(commandToExec, 'sqli')
            .then((commandOutput) => {
                resolve(commandOutput);
            })
            .catch((err) => {
                reject(err);
            });
    });
};

const xssScan = (url, proxy) => {
    return new Promise((resolve, reject) => {
        command.execCommand(config.WAPITI + ' -u ' + checkURL(url) + ' -m ' + config.wapiti_xss + ' -f json -o outputs/wapitiOutput_xss', 'xss')
            .then((commandOutput) => {
                resolve(commandOutput);
            })
            .catch((err) => {
                reject(err);
            });
    });
};

function checkProxy(proxy) {
    if (proxy.startsWith('http')) {
        return proxy;
    } else {
        return 'http://' + proxy;
    }
}

function toJson(file) {
    return new Promise((resolve, reject) => {
        let rawData = fs.readFileSync(file);
        let json = JSON.parse(rawData);
        console.log('Finshed Convertion wapiti.');
        resolve(json);
    });
}

function getInfo(json) {
    return new Promise((resolve, reject) => {
        // TODO: parse JSON
    });
}

function wapitiTool(url, type, proxy) {
    return new Promise((resolve, reject) => {
        switch (type) {
            case "default":
                wapitiTool_default(url, proxy)
                    .then(commandOutput => resolve(commandOutput))
                    .catch(err => reject(err));
                break;
            case "sqli":
                wapitiTool_sqli(url, proxy)
                    .then(commandOutput => resolve(commandOutput))
                    .catch(err => reject(err));
                break;
            case "xss":
                wapitiTool_xss(url, proxy)
                    .then(commandOutput => resolve(commandOutput))
                    .catch(err => reject(err));
                break;
        }
    });
}

function wapitiTool_default(url, proxy) {
    return new Promise((resolve, reject) => {
        io.emit('progress', 'Searching for vulnerabilities..');
        // toJson('outputs/wapitiOutput')
        //     .then((json) => {
        //         resolve(json)
        //     })
        //     .catch((err) => {
        //         reject(err);
        //     });
        // COMMENTED FOR TESTING PURPOSES
        defaultScan(url, proxy)
            .then((commandOutput) => {
                if (commandOutput !== 'success') {
                    reject('failed');
                }
                toJson('outputs/wapitiOutput')
                    .then((json) => {
                        resolve(json)
                    })
                    .catch((err) => {
                        reject(err);
                    });
            })
            .catch((err) => {
                reject(err);
            });
    });
}

function wapitiTool_sqli(url, proxy) {
    return new Promise((resolve, reject) => {
        io.emit('progress', 'Searching for SQLi vulnerabilities..');
        // toJson('outputs/wapitiOutput_sqli')
        //     .then((json) => {
        //         resolve(json)
        //     })
        //     .catch((err) => {
        //         reject(err);
        //     });
        // COMMENTED FOR TESTING PURPOSES
        sqliScan(url, proxy)
            .then((commandOutput) => {
                if (commandOutput !== 'success') {
                    reject('failed');
                }
                toJson('outputs/wapitiOutput_sqli')
                    .then((json) => {
                        resolve(json)
                    })
                    .catch((err) => {
                        reject(err);
                    });
            })
            .catch((err) => {
                reject(err);
            });
    });

}

function checkURL(url) {
    let newUrl = url;
    if (url.endsWith('/')) {
        newUrl = newUrl;
    } else {
        newUrl = newUrl + '/';
    }

    if (url.startsWith('http')) {
        newUrl = newUrl
    } else {
        newUrl = 'http://' + newUrl;
    }

    return newUrl;
}

function wapitiTool_xss(url, proxy) {
    return new Promise((resolve, reject) => {
        io.emit('progress', 'Searching for XSS vulnerabilities..');
        // toJson('outputs/wapitiOutput_xss')
        //     .then((json) => {
        //         resolve(json)
        //     })
        //     .catch((err) => {
        //         reject(err);
        //     });
        // COMMENTED FOR TESTING PURPOSES
        xssScan(url, proxy)
            .then((commandOutput) => {
                if (commandOutput !== 'success') {
                    reject('failed');
                }
                toJson('outputs/wapitiOutput_xss')
                    .then((json) => {
                        resolve(json)
                    })
                    .catch((err) => {
                        reject(err);
                    });
            })
            .catch((err) => {
                reject(err);
            });
    });

}


module.exports = {
    wapitiTool: async(url, type, proxy = "") => {
        return await wapitiTool(url, type, proxy);
    }
};